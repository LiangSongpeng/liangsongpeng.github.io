---
layout: post
title:  "C++ 内存分布"
---

* content
{:toc}

## C++ 内存分布

每个程序运行起来以后，它将拥有自己独立的虚拟地址空间。这个虚拟地址空间的大小与操作系统的位数有关系。例如 32 位硬件平台的虚拟地址空间的地址可以从 0~2<sup>32</sup>-1，即 0x00000000~0xFFFFFFFF，总共 4 GB 大小。在32位 Windows 操作系统中，高地址的 2 GB 位内核空间，用户空间只有 2 GB。而 64 位操作系统，用户可用空间则要大的多。

**C/C++ 程序在虚拟内存中的排布如下所示（仅仅列出了相关的主要段）（由高地址至低地址）：**

> - 内核
> - 栈区
>
> - 缓冲区
>
> - 堆区
>
> - 全局区
>
> - 只读常量区
>
> - 代码段

1. 栈区（stack）： 由编译器自动分配与释放，存放为运行时函数分配的局部变量、函数参数、返回数据、返回地址等。其操作类似于数据结构中的栈。栈内存分配效率高，但存储空间有限。

2. 堆区（heap） ： 一般由程序员分配释放， 若程序员不释放，在程序结束时，操作系统回收。它与数据结构中的堆是两回事，其分配类似于链表。每个 new 都应该对应于一个 delete，如果程序员忘记释放堆内存，则在程序最后结束后会由操作系统完成释放，但在程序运行过程中可能会造成堆区越来越大，从而造成内存溢出。

3. 全局区（静态区）：全局变量和静态变量的存储是放在一块的， 在程序序结束后由系统释放（全局变量、静态数据、常量）。 在 C 语言中，全局区分为已初始化全局区（data）和未初始化全局区（bss）。

4. 常量区 ：常量字符串就是放在这里的。 程序结束后由系统释放 。

5. 代码段：存放函数体（类成员函数和全局区）的二进制代码。


> 堆是 C 语言和操作系统的术语、是操作系统维护的一块内存，而自由存储是 C++ 中通过 new 与 delete 动态分配和释放对象的抽象概念。堆与自由存储区并不等价。
>
> new 所申请的内存区域在 C++ 中称为自由存储区。藉由堆实现的自由存储，可以说 new 所申请的内存区域在堆上。

> 全局常变量存储在只读常量区，其不可修改性由操作系统保障。 
>
> 局部常变量存储在栈区，其不可修改性仅仅是由编译器来保证，因此可以用 const_cast。

**内存分配方式有三种：**  

1. 从静态存储区域分配。内存在程序编译的时候就已经分配好，这块内存在程序的整个运行期间都存在。例如全局变量，static 变量。
2. 在栈上创建。在执行函数时，函数内局部变量的存储单元都可以在栈上创建，函数执行结束时这些存储单元自动被释放。栈内存分配运算内置于处理器的指令集中，效率很高，但是分配的内存容量有限。
3. 从堆上分配，亦称动态内存分配。程序在运行的时候用 malloc 或 new 申请任意多少的内存，程序员自己负责在何时用 free 或 delete 释放内存。动态内存的生存期由我们决定，使用非常灵活，但问题也最多。

**明确区分栈与堆**：

理解这个问题最好的办法就是下面的例子：

```c++
void fun()
{
	int *p = new int[5];
}
```

在上面的例子中，p 存储在栈区，因为其是函数的局部变量，而 p 指向的空间（是一个存储 int 的数组）则存储在堆区。

**栈与堆的不同：**

- 管理方式不同。
- 空间大小不同：栈的大小一般是以 MB 为单位的。
- 能否产生碎片不同：由于管理方式的不同，所以堆更容易产生碎片。这是由于频繁调用 new/delete 而造成内存空间不连续。而对于栈，其由操作系统管理，每次弹出的内存块意味着它上面的内存块也已经弹出，所以几乎不会产生碎片。
- 生长方式不同：堆的生长方向是向上的，也就是向着内存地址增加的方向；而对于栈，其的生长放下是向下的，向着内存地址减小的方向生长。
- 分配方式不同：堆是动态分配的；而栈其实具有两种分配方式，在栈的静态分配中是由编译器完成的，如局部变量的分配；动态分配的栈是由函数 alloca 完成的，虽然是动态分配的栈，但是我们也无需对其进行手工释放，也是由操作系统完成的。
- 分配效率不同： 栈是及其系统提供的数据结构，计算机对其底层提供支持，有专门的寄存器存放栈的地址，并有专门的指令执行 push/pop 等操作。而堆是由库函数提供的，其机制很复杂。

**关于内存的较好的编程习惯：**

- 用 malloc 或 new 申请内存之后，应该立即检查指针值是否为 NULL。防止使用指针值为 NULL 的内存。
- 不要忘记为数组和动态内存赋初值。防止将未被初始化的内存作为右值使用。
- 避免数组或指针的下标越界，特别要当心发生“多1”或者“少1”操作。
- 动态内存的申请与释放必须配对，防止内存泄漏。
- 用 free 或 delete 释放了内存之后，立即将指针设置为 NULL ，防止产生“野指针”。