---
layout: post
title:  "动态规划与贪婪算法 & C++"
---

* content
{:toc}

## 动态规划 & 贪婪算法

动态规划，是针对一种最优化问题。应用动态规划前，将大问题分解成小问题，分解后的每个小问题存在局部最优解。把局部解组合起来得到**整体最优解**。

贪婪算法（又称贪心算法）是指，在对问题求解时，总是做出在当前看来是最好的选择。也就是说，不从整体最优上加以考虑，他所做出的是在某种意义上的**局部最优解**。贪婪算法不是对所有问题都能得到整体最优解，关键是贪婪策略的选择，选择的贪婪策略必须具备无后效性，即某个状态以前的过程不会影响以后的状态，只与当前状态有关。

同：

- 都是一种推导算法。
- 都是分解成子问题来求解，都需要具有最优子结构。

异：

- 动态规划：全局最优解中一定包含某个局部最优解，但不一定包含前一个局部最优解，需要记录之前的所有的局部最优解。贪婪算法：每一步的最优解一定包含上一步的最优解，上一步之前的最优解无需保留。

- 动态规划：动态规划自底向上，**从叶子向根**求解问题，构造子问题的解，对每一个子树的根，求出下面每一个叶子的值，**最后得到一棵完整的树**，并且最终选择其中的最优值作为自身的值，得到答案。贪婪算法：如果把所有的子问题看成一棵树的话，贪婪算法**从根向叶子**求解问题，每次向下遍历最优子树即可（通常这个“最优”都是基于当前情况下显而易见的“最优”）；这样的话，就不需要知道一个节点的所有子树情况，于是**构不成一棵完整的树**。
- 动态规划本质是穷举法，可以保证**结果是最佳的**，**复杂度高**。贪婪算法不能保证求得的最后解是最佳的，一般**复杂度低**。

<!-- more --> <!-- 摘要预览与正文的分隔符 -->

---

## C++ 实现

> 问题：给你一根长度为 n 绳子，请把绳子剪成 m 段（m、n 都是整数，n>1 并且 m≥1）。每段的绳子的长度记为 k[0]、k[1]、……、k[m]。k[0]*k[1]*…*k[m] 可能的最大乘积是多少？例如当绳子的长度是 8 时，我们把它剪成长度分别为 2、3、3 的三段，此时得到最大的乘积 18。

**动态规划：**

**从下向上**求解。定义函数 f(n) 为把长度为 n 的绳子剪成若干段后各段长度乘积的最大值， f(n) = max(f(i) * f(n-i))。先求得 f(2)、f(3)，再得到 f(4)、f(5)，直到 f(n)。当绳子长度为 2 时，只可能剪成长度都为 1 的两段， f(2) 等于 1，当绳子长度为 3 时，可能把绳子剪成长度分别为 1 和 2 的两段或者长度都为 1 的三段，但由于 1 * 2 > 1 * 1 * 1，所以 f(3) = 2。以此类推。

```c++
int maxProductAfterCutting(int length)
{
    if(length < 2)
        return 0;
    if(length == 2)
        return 1;
    if(length == 3)
        return 2;

    int* products = new int[length + 1];
    products[0] = 0;
    products[1] = 1;
    products[2] = 2;
    products[3] = 3;
    
    int max = 0;
    for(int i = 4; i <= length; ++i)
    {
        max = 0;
        for(int j = 1; j <= i / 2; ++j)
        {
            int product = products[j] * products[i - j];
            if(max < product)
                max = product;
    
            products[i] = max;
        }
    }
    
    max = products[length];
    delete[] products;
    
    return max;
}
```

**贪婪算法：**

**从上向下**求解。当 n≥5 时，我们尽可能多地剪长度为 3 的绳子；当剩下的绳子长度为 4 时，把绳子剪成两段长度为 2 的绳子。以此类推。

```c++
int maxProductAfterCutting(int length)
{
    if(length < 2)
        return 0;
    if(length == 2)
        return 1;
    if(length == 3)
        return 2;

    // 尽可能多地减去长度为3的绳子段
    int timesOf3 = length / 3;

    // 当绳子最后剩下的长度为4的时候，不能再剪去长度为3的绳子段。
    // 此时更好的方法是把绳子剪成长度为2的两段，因为2*2 > 3*1。
    if(length - timesOf3 * 3 == 1)
        timesOf3 -= 1;

    int timesOf2 = (length - timesOf3 * 3) / 2;

    return (int) (pow(3, timesOf3)) * (int) (pow(2, timesOf2));
}
```

