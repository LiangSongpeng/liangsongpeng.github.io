---
layout: post
title:  "MFC 实现截图功能"
---

* content
{:toc}

## MFC 实现截图功能设计思路

使用 MFC 来实现截图功能，主要是想实现自定义截图功能，即用户可以自行拖拽截图所用的矩形选择框，以此来选择想要截取区域的图像。

主要实现方法及思路：

> 1、确定截图的矩形范围，再复制、保存。
> <br/>2、画矩形，即在用户使用截图功能时，响应鼠标左键的按下和弹起消息，在鼠标按下时和鼠标弹起时分别保存光标的坐标信息。从而确定用户需要的截图范围。
> <br/>3、但这样存在一个问题，即只有在用户鼠标左键弹起之后才能画出用户选择的矩形范围。
> <br/>4、为了解决上述问题，实现当鼠标左键按下时，开始画矩形，随着光标的移动，不断重绘矩形的效果，需要确定矩形的两个坐标，即矩形左上角的坐标和矩形右下角的坐标。startPoint即为鼠标左键按下时的光标位置，而endPoint则是变化的，在鼠标左键按下至弹起的这段时间内的光标位置都是endPoint的值。
> <br/>5、这样做之后虽然能够实现动态的画矩形，但是也会存在另一个问题，那就是在鼠标左键按下到弹起的过程中会画很多的矩形，而这些矩形都会显示在屏幕上，即随着光标的移动，画出新矩形的同时旧的矩形并没有消失。
> <br/>6、为了解决上述问题，可以在画矩形时，记录下它的位置，当画新的矩形时，用矩形所在窗口的原本颜色再画一个矩形将其覆盖。
> <br/>7、动态画矩形的问题基本解决了，但还是存在一个问题，即响应鼠标左键按下和弹起消息的问题，因为通过ClassWizard添加的WM_LBUTTONDOWN和WM_LBUTTONUP消息只是针对本程序的，也就是说这两个消息并不能响应截图程序之外的鼠标消息。而我们需要截图的地方显然不可能只是截图程序本身的窗口，当我们的鼠标点击在截图程序的窗口之外后，截图程序就丢失了焦点，也就响应不了上述两个消息了。
> <br/>8、为解决上述问题，有两种方法：（1）是截取系统范围内的鼠标消息；（2）设置一个透明、无标题栏、无边框、最大化显示、置顶显示的对话框，以此来响应截图程序中的鼠标消息。

---

## MFC 实现截图功能中所遇到刷新问题及解决方法

想要实现自定义截图，便需要解决一个问题，即矩形选择框应画在什么位置？

若是直接通过GetDesktopWindow()和GetWindowDC()函数在桌面环境上绘图，便会遇到刷新所带来的问题，即在绘制矩形选择框时，若是桌面有所刷新则会影响矩形框的绘制。

所以，为了解决此问题，可以使用一个透明、无标题栏、无边框、最大化显示、置顶显示的对话框，在将要绘制矩形框时，则调用此对话框，然后将矩形框绘制到此对话框上。此对话框的作用只是为了提供一个用户画矩形的载体，而用户画矩形的目的是为了得到截图的矩形区域，所以在确定了这个矩形范围之后，这个对话框（在调用截图函数之前）会马上关闭。

所以在 MFC 实现截图功能主要实现方法及思路第8点中所提到的两种解决方法中，应选择方法（2），此方法既可以解决消息响应的问题，又可以解决屏幕刷新的问题，此为最好的方法。**实在是太厉害了吧！ ( •̀ ω •́ )✧ （呕**

此透明的对话框可以采用模态对话框，因为该窗口只在画矩形时出现。

设置窗口透明可用到函数SetLayeredWindowAttributes()。

``` c++
BOOL SetLayeredWindowAttributes(
    HWND hwnd,          // 指定分层窗口句柄
    COLORREF crKey,     // 指定需要透明的背景颜色值，可用RGB()宏
    BYTE bAlpha,        // 设置透明度，0表示完全透明，255表示不透明
    DWORD dwFlags       // 透明方式
);
```

> 其中，dwFlags参数可取以下值：
> <br/>LWA_ALPHA：crKey参数无效，bAlpha参数有效。
> <br/>LWA_COLORKEY：窗体中的所有颜色为crKey的地方将变为透明，bAlpha参数无效。
> <br/>LWA_ALPHA | LWA_COLORKEY：crKey的地方将变为全透明，而其它地方根据bAlpha参数确定透明度。
